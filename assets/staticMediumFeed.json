{"title":"Stories by Spencer Attick (he/him) on Medium","description":"Stories by Spencer Attick (he/him) on Medium","link":"https://medium.com/@spencer.attick?source=rss-e5dc359f27c2------2","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*-uzWbooKuJ4W-gL2TBuWkA.png","category":[],"items":[{"id":"https://medium.com/p/f5efe0afd046","title":"Project: Updating Segment’s analytics-node Library to Include TypeScript","link":"https://medium.com/@spencer.attick/project-updating-segments-analytics-node-library-to-include-typescript-f5efe0afd046?source=rss-e5dc359f27c2------2","author":"Spencer Attick (he/him)","published":1678993785000,"created":1678993785000,"category":["segment","codecademy","node","typescript"],"content":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UU7ZZ5HrY8Iq7OfJrk2P2Q.png\" /></figure><p>In working as a Success Engineer at Segment, I’ve gotten a chance to get very familiar with the integration libraries Segment offers in various languages. In looking for some proactive ways I could help out our customer-base, I noticed several folks asking for TypeScript support in Segment’s <a href=\"https://segment.com/docs/connections/sources/catalog/libraries/server/node/\">analytics-node</a> library. Having never worked with TypeScript, I thought it would be a great opportunity to gain some experience with a technology new to me.</p><h3>The Problem</h3><p>A few customers had pointed out that they had run into issues using Segment’s analytics-node library that could have easily been avoided if the library had been refactored to use TypeScript. They pointed out that the addition would be fairly easy and wouldn’t take much time. Reading through requests for TypeScript that could have saved our customers time and frustration, I went ahead and took the project onto make the update.</p><h3>The Work</h3><p>The first step I took was to take <a href=\"https://www.codecademy.com/learn/learn-typescript\">Codecademy’s fantastic course on TypeScript</a> to learn what it was all about. There I got practice with the syntax and requirements that TypeScript imposes on top of Javascript. The course also shared the reasons behind TypeScript and how to get started in using it more broadly.</p><p>From there, I forked Segment’s existing library to get a refresher on how it worked currently.</p><p>After getting the lay of the land, I consulted <a href=\"https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html\">TypeScript’s documentation</a> regarding migration from a Javascript project to one written in TypeScript. After all, I had just been learning in Codecademy’s pre-established environment and had yet to write any TypeScript in the wild. I found the documentation to be very straightforward and soon had the project configured correctly to throw TypeScript errors that I could then work through solving.</p><p>Before hopping into that error set, I saw immediately that there were some obvious changes I could make in terms of adding types to variables already listed at the top of the main file and taking on other small updates.</p><p>After making any necessary changes that stood out to me, I went back and forth running the TypeScript file and the existing test file that the Segment team had written to correct the code making sure to gradually reduce errors that cropped up in either place. I ran into many TypeScript file updates breaking the test file and vice versa which was a truly great learning experience complete with countless trips to Stack Overflow.</p><p>As I was acquiring a ton of new knowledge and had cleared out most of the errors that TypeScript had found and all of the ones that came up through Segment’s test suite, I became aware that Segment was actually writing a brand new library for Node and that the one I was working on would be relegated to maintenance mode. Upon learning that, I didn’t want to leave my project unfinished so I worked on cleaning up the last few errors before ultimately submitting all of my updates as a pull request. I was concerned they wouldn’t merge a change like this with the new library on the horizon so I did disable a few pieces of TypeScript functionality to get my pull request in before too much time elapsed. My hope was that I could continue to work on the project and clear those final errors if the team was interested in merging my code. When the team reviewed what I had written, they were appreciative but ultimately decided not to more forward with it in favor of the new library.</p><p>In the end, I got a lot of value from the opportunity my role gave me to find a gap like this, to learn the necessary technology, and to refactor existing code to meet the needs of Segment’s customers. Even though my code wasn’t merged it was a great learning experience.</p><h3>The Code</h3><p>Here is the pull request I made on the analytics-node library to incorporate TypeScript: <a href=\"https://github.com/segmentio/analytics-node/pull/356\">https://github.com/segmentio/analytics-node/pull/356</a>.</p><h3>What I Learned</h3><p>I got to learn TypeScript!</p><p>More importantly, I also learned that, though I was interested in working on a project just to help out and to practice a new skill, it would have been a good step to take to communicate with Segment’s libraries team about my interested in making the update. If I had, perhaps they would have been able to share that they were already working on something new and I could have seen if there was anything I could have helped with in that codebase instead.</p><p>Overall, I got some excellent experience in terms of technology and process that I can take with me onto whatever comes next!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f5efe0afd046\" width=\"1\" height=\"1\" alt=\"\">","enclosures":[],"content_encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UU7ZZ5HrY8Iq7OfJrk2P2Q.png\" /></figure><p>In working as a Success Engineer at Segment, I’ve gotten a chance to get very familiar with the integration libraries Segment offers in various languages. In looking for some proactive ways I could help out our customer-base, I noticed several folks asking for TypeScript support in Segment’s <a href=\"https://segment.com/docs/connections/sources/catalog/libraries/server/node/\">analytics-node</a> library. Having never worked with TypeScript, I thought it would be a great opportunity to gain some experience with a technology new to me.</p><h3>The Problem</h3><p>A few customers had pointed out that they had run into issues using Segment’s analytics-node library that could have easily been avoided if the library had been refactored to use TypeScript. They pointed out that the addition would be fairly easy and wouldn’t take much time. Reading through requests for TypeScript that could have saved our customers time and frustration, I went ahead and took the project onto make the update.</p><h3>The Work</h3><p>The first step I took was to take <a href=\"https://www.codecademy.com/learn/learn-typescript\">Codecademy’s fantastic course on TypeScript</a> to learn what it was all about. There I got practice with the syntax and requirements that TypeScript imposes on top of Javascript. The course also shared the reasons behind TypeScript and how to get started in using it more broadly.</p><p>From there, I forked Segment’s existing library to get a refresher on how it worked currently.</p><p>After getting the lay of the land, I consulted <a href=\"https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html\">TypeScript’s documentation</a> regarding migration from a Javascript project to one written in TypeScript. After all, I had just been learning in Codecademy’s pre-established environment and had yet to write any TypeScript in the wild. I found the documentation to be very straightforward and soon had the project configured correctly to throw TypeScript errors that I could then work through solving.</p><p>Before hopping into that error set, I saw immediately that there were some obvious changes I could make in terms of adding types to variables already listed at the top of the main file and taking on other small updates.</p><p>After making any necessary changes that stood out to me, I went back and forth running the TypeScript file and the existing test file that the Segment team had written to correct the code making sure to gradually reduce errors that cropped up in either place. I ran into many TypeScript file updates breaking the test file and vice versa which was a truly great learning experience complete with countless trips to Stack Overflow.</p><p>As I was acquiring a ton of new knowledge and had cleared out most of the errors that TypeScript had found and all of the ones that came up through Segment’s test suite, I became aware that Segment was actually writing a brand new library for Node and that the one I was working on would be relegated to maintenance mode. Upon learning that, I didn’t want to leave my project unfinished so I worked on cleaning up the last few errors before ultimately submitting all of my updates as a pull request. I was concerned they wouldn’t merge a change like this with the new library on the horizon so I did disable a few pieces of TypeScript functionality to get my pull request in before too much time elapsed. My hope was that I could continue to work on the project and clear those final errors if the team was interested in merging my code. When the team reviewed what I had written, they were appreciative but ultimately decided not to more forward with it in favor of the new library.</p><p>In the end, I got a lot of value from the opportunity my role gave me to find a gap like this, to learn the necessary technology, and to refactor existing code to meet the needs of Segment’s customers. Even though my code wasn’t merged it was a great learning experience.</p><h3>The Code</h3><p>Here is the pull request I made on the analytics-node library to incorporate TypeScript: <a href=\"https://github.com/segmentio/analytics-node/pull/356\">https://github.com/segmentio/analytics-node/pull/356</a>.</p><h3>What I Learned</h3><p>I got to learn TypeScript!</p><p>More importantly, I also learned that, though I was interested in working on a project just to help out and to practice a new skill, it would have been a good step to take to communicate with Segment’s libraries team about my interested in making the update. If I had, perhaps they would have been able to share that they were already working on something new and I could have seen if there was anything I could have helped with in that codebase instead.</p><p>Overall, I got some excellent experience in terms of technology and process that I can take with me onto whatever comes next!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f5efe0afd046\" width=\"1\" height=\"1\" alt=\"\">","media":{}},{"id":"https://medium.com/p/9251d1438121","title":"Project: Segment Source Function — Auth0","link":"https://medium.com/@spencer.attick/project-segment-source-function-auth0-9251d1438121?source=rss-e5dc359f27c2------2","author":"Spencer Attick (he/him)","published":1678737033000,"created":1678737033000,"category":["auth0","javascript","node","segment"],"content":"<h3>Project: Segment Source Function — Auth0</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oFHanJWMIJFVh6Yr52Lviw.png\" /></figure><h3>Segment Source Functions</h3><p>As a Success Engineer at Segment, I’ve had great opportunities to practice and level-up my development skills. One of the ways I’ve used my coding skills to help our customers get set up as quickly as possible was to write a Function that met the needs of folks attempting to use a third-party tool and which removed the necessity for their teams to have to set up a file from scratch to accomplish the task they were interested in.</p><p>In the Segment ecosystem, a <a href=\"https://segment.com/docs/connections/functions/\">Function</a> is a feature where custom code can be written and executed either before data formally enters the Segment processing pipeline (Source Functions) or at the end of the pipeline to push data out to non-Segment entities (Destination Functions). Folks will usually use Functions to send data to Segment from a source that isn’t supported by the product directly or to send data out to a destination that Segment doesn’t support out-of-the-box. The Function environment is highly customizable and can act as a stand in for part of a customer’s codebase.</p><p>Because the feature is so open-ended, Segment maintains an open source <a href=\"https://github.com/segmentio/functions-library\">library</a> to give customers a starting point for writing Source or Destination Functions for entities that are frequently asked about.</p><p>When I saw two separate requests come in from customers in one week asking for help to send data into Segment from <a href=\"https://auth0.com/docs\">Auth0</a> I decided to take on the project of creating a connector template that customers could use to set that connection up without having to start from scratch.</p><h3>The Problem</h3><p>Auth0’s platform had <a href=\"https://auth0.com/docs/customize/extensions/export-log-events-with-extensions\">previously supported a direct integration to Segment </a>but was in the process of deprecating that connection. If customers wanted to send data from Auth0 to Segment, the easiest way to do so would be via a Source Function.</p><p>While Segment’s ingestion API has a particular data format it requires, a Source Function can accept any configuration of data (as long as it’s JSON). That means that customers can send data to a Source Function from nearly anywhere and then write custom code in their Function to transform that data into something Segment’s API will accept.</p><p>As such, the project here involved looking at the data Auth0 could send out to a webhook and then to write code to make that data usable within Segment in a way that wouldn’t make too many assumptions. After all, this was meant to be a reusable file that customers could change to fit their individual needs.</p><h3>The Work</h3><p>In looking at the data Auth0 sent out in their logs to a webhook, I noticed that they didn’t include an event name that could be easily referenced. Data is much more usable if it hits Segment with a coherent <a href=\"https://segment.com/docs/connections/spec/track/#event:~:text=Name%20of%20the%20action%20that%20a%20user%20has%20performed.%20See%20the%20Event%20field%20docs%20for%20more%20details.\">event name</a> that can be used to organize or analyze data in downstream tools (ex. Amplitude, Redshift, Mixpanel, Google Analytics, etc.). To this end, I found a <a href=\"https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes\">guide</a> that maps log codes (which Auth0 sends in their payloads) to more easily understandable event names. I used that to start to build a payload that could be sent to Segment. From there, I opted to send all of the other pieces of information from the Auth0 log to Segment as <a href=\"https://segment.com/docs/connections/spec/track/#event:~:text=Free%2Dform%20dictionary,reserved%20property%20names.\">properties</a> so that customers could start with the whole set but, of course, could pare things down if they decided they needed to.</p><p>Once the information to be added to the payload the was sorted, I noticed that the resulting requests could be quite large. I wanted to make sure that the event my code generated would be within <a href=\"https://segment.com/docs/connections/sources/catalog/libraries/server/http-api/#max-request-size\">Segment’s size parameters</a> so I added some validation in to do that. If the payload was within Segment’s limit, my code would go ahead and send it on, if not, I opted to remove a section of the payload that I noticed often accounted for a size issue and didn’t seem like incredibly relevant data to hold onto. Of course, customers then had the template for doing this I wrote so they could easily decide to remove a different section based on what they found relevant. I left comments in my code to ensure these checks and the removal was obvious as Segment users come from all different backgrounds and some are more technical than others.</p><h3>The Code</h3><p>Segment’s teams are in the process of restructuring, so for now there is a backlog of pull requests on the Function’s library repo. That said, here is my pull request awaiting a time when it can be merged: <a href=\"https://github.com/segmentio/functions-library/pull/70\">https://github.com/segmentio/functions-library/pull/70</a>.</p><p>I’ve been able to share that solution with customers who’ve asked about getting set up with Auth0 so they don’t have to start from scratch.</p><p>Overall, this has been a great (albeit small) opportunity to get some practice while helping out Segment’s customer base.</p><h3>What I Learned</h3><p>Through this project, it was reinforced for me that I don’t need to take on a large-scale project to make an impact. A smaller implementation with just around ~150 lines of code can be great practice and can really help our customers get started with what they’re hoping to do so they can spend less time writing custom code and more time getting their data pipeline dialed in. Since this Function template is reusable, customers from here on out can use it however they see fit in order to send their Auth0 logs to Segment.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9251d1438121\" width=\"1\" height=\"1\" alt=\"\">","enclosures":[],"content_encoded":"<h3>Project: Segment Source Function — Auth0</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oFHanJWMIJFVh6Yr52Lviw.png\" /></figure><h3>Segment Source Functions</h3><p>As a Success Engineer at Segment, I’ve had great opportunities to practice and level-up my development skills. One of the ways I’ve used my coding skills to help our customers get set up as quickly as possible was to write a Function that met the needs of folks attempting to use a third-party tool and which removed the necessity for their teams to have to set up a file from scratch to accomplish the task they were interested in.</p><p>In the Segment ecosystem, a <a href=\"https://segment.com/docs/connections/functions/\">Function</a> is a feature where custom code can be written and executed either before data formally enters the Segment processing pipeline (Source Functions) or at the end of the pipeline to push data out to non-Segment entities (Destination Functions). Folks will usually use Functions to send data to Segment from a source that isn’t supported by the product directly or to send data out to a destination that Segment doesn’t support out-of-the-box. The Function environment is highly customizable and can act as a stand in for part of a customer’s codebase.</p><p>Because the feature is so open-ended, Segment maintains an open source <a href=\"https://github.com/segmentio/functions-library\">library</a> to give customers a starting point for writing Source or Destination Functions for entities that are frequently asked about.</p><p>When I saw two separate requests come in from customers in one week asking for help to send data into Segment from <a href=\"https://auth0.com/docs\">Auth0</a> I decided to take on the project of creating a connector template that customers could use to set that connection up without having to start from scratch.</p><h3>The Problem</h3><p>Auth0’s platform had <a href=\"https://auth0.com/docs/customize/extensions/export-log-events-with-extensions\">previously supported a direct integration to Segment </a>but was in the process of deprecating that connection. If customers wanted to send data from Auth0 to Segment, the easiest way to do so would be via a Source Function.</p><p>While Segment’s ingestion API has a particular data format it requires, a Source Function can accept any configuration of data (as long as it’s JSON). That means that customers can send data to a Source Function from nearly anywhere and then write custom code in their Function to transform that data into something Segment’s API will accept.</p><p>As such, the project here involved looking at the data Auth0 could send out to a webhook and then to write code to make that data usable within Segment in a way that wouldn’t make too many assumptions. After all, this was meant to be a reusable file that customers could change to fit their individual needs.</p><h3>The Work</h3><p>In looking at the data Auth0 sent out in their logs to a webhook, I noticed that they didn’t include an event name that could be easily referenced. Data is much more usable if it hits Segment with a coherent <a href=\"https://segment.com/docs/connections/spec/track/#event:~:text=Name%20of%20the%20action%20that%20a%20user%20has%20performed.%20See%20the%20Event%20field%20docs%20for%20more%20details.\">event name</a> that can be used to organize or analyze data in downstream tools (ex. Amplitude, Redshift, Mixpanel, Google Analytics, etc.). To this end, I found a <a href=\"https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes\">guide</a> that maps log codes (which Auth0 sends in their payloads) to more easily understandable event names. I used that to start to build a payload that could be sent to Segment. From there, I opted to send all of the other pieces of information from the Auth0 log to Segment as <a href=\"https://segment.com/docs/connections/spec/track/#event:~:text=Free%2Dform%20dictionary,reserved%20property%20names.\">properties</a> so that customers could start with the whole set but, of course, could pare things down if they decided they needed to.</p><p>Once the information to be added to the payload the was sorted, I noticed that the resulting requests could be quite large. I wanted to make sure that the event my code generated would be within <a href=\"https://segment.com/docs/connections/sources/catalog/libraries/server/http-api/#max-request-size\">Segment’s size parameters</a> so I added some validation in to do that. If the payload was within Segment’s limit, my code would go ahead and send it on, if not, I opted to remove a section of the payload that I noticed often accounted for a size issue and didn’t seem like incredibly relevant data to hold onto. Of course, customers then had the template for doing this I wrote so they could easily decide to remove a different section based on what they found relevant. I left comments in my code to ensure these checks and the removal was obvious as Segment users come from all different backgrounds and some are more technical than others.</p><h3>The Code</h3><p>Segment’s teams are in the process of restructuring, so for now there is a backlog of pull requests on the Function’s library repo. That said, here is my pull request awaiting a time when it can be merged: <a href=\"https://github.com/segmentio/functions-library/pull/70\">https://github.com/segmentio/functions-library/pull/70</a>.</p><p>I’ve been able to share that solution with customers who’ve asked about getting set up with Auth0 so they don’t have to start from scratch.</p><p>Overall, this has been a great (albeit small) opportunity to get some practice while helping out Segment’s customer base.</p><h3>What I Learned</h3><p>Through this project, it was reinforced for me that I don’t need to take on a large-scale project to make an impact. A smaller implementation with just around ~150 lines of code can be great practice and can really help our customers get started with what they’re hoping to do so they can spend less time writing custom code and more time getting their data pipeline dialed in. Since this Function template is reusable, customers from here on out can use it however they see fit in order to send their Auth0 logs to Segment.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9251d1438121\" width=\"1\" height=\"1\" alt=\"\">","media":{}},{"id":"https://medium.com/p/7f03b1b9e1b9","title":"Scope, Hoisting, and Closure in Javascript","link":"https://medium.com/@spencer.attick/scope-and-hoisting-and-closure-in-javascript-7f03b1b9e1b9?source=rss-e5dc359f27c2------2","author":"Spencer Attick (he/him)","published":1675365832000,"created":1675365832000,"category":["javascript-tips","hoisting","javascript","scopes","closure"],"content":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*qJ8E0-P3Y7pMgstD\" /></figure><p>So you’ve learned how to execute functions and have maybe even written a few simple programs. Nice! Now it’s time to level up with some more advanced Javascript concepts. Understanding scope, hoisting, and closure are essential to internalizing how your programs will run and what behavior you can expect for certain situations that can really trip you up if you’re unclear on these concepts.</p><p>Let’s get into it!</p><h3>Scope</h3><p>The first of these concepts to understand is scope. When we’re talking about scope we’re referring to where in the program variables are accessible. There are four types of scope:</p><p><strong>Global Scope</strong></p><p>With global scope, variables are declared in such a way that makes them accessible to an entire file. To scope variables globally you just declare them outside of any functions or modules. This isn’t recommended as you might declare a global variable, forget about it, and then attempt to use the same variable in a different way elsewhere in you code which can create unexpected behavior and cause confusion, especially if you’re working with a team.</p><p>Here is an example of a variable defined with global scope:</p><pre>// Define a global variable<br>let globalVariable = 'I am a global variable';<br><br>// Define a global function<br>function globalFunction() {<br>  console.log(globalVariable);<br>}<br><br>// Call the global function from anywhere in the program<br>globalFunction(); // outputs: 'I am a global variable'</pre><p>The globalVariable and globalFunction values can be referenced anywhere in the file in which they are instantiated (though there are some limitations around hoisting which we’ll discuss later).</p><p>In Javascript, each file you create has its own global scope. You can’t share information between files without modular scope.</p><p><strong>Modular Scope</strong></p><p>Modular scope refers to a process by which variables are encapsulated in a module (ES6 offers this functionality). That module can then be shared with other parts of your program. With modular scope, variables and functions can be accessed in their own module and any other places where that module is imported.</p><p>Here is an example:</p><pre>// Define a module<br>module.exports = {<br>  moduleVariable: 'I am a module variable',<br>  moduleFunction: function() {<br>    console.log(this.moduleVariable);<br>  }<br>};</pre><pre>// Import the module into another file<br>const myModule = require('./myModule');<br><br>// Call the module function<br>myModule.moduleFunction(); // outputs: 'I am a module variable'</pre><p><strong>Block Scope</strong></p><p>Block scope refers to anything contained between two curly braces {} . This includes things like variables created within a function or variables between curly braces inif statements.</p><p>Here in an example of block scoping:</p><pre>if (true) {<br>  let x = 10;<br>}<br>console.log(x); // ReferenceError: x is not defined</pre><p>The x variable is blocked scoped (due to the use of let) and cannot be referenced outside of the curly braces it is contained in.</p><p>Please note here that var is function scoped (we’ll talk about this in just a second) but let and const are block scoped. I won’t go into that too much about var here, but in 2023 there are very few cases where it is needed so Javascript developers should be sticking with let and const .</p><p><strong>Function Scope</strong></p><p>Function scope and block scope are essentially the same thing unless you’re using the var keyword. It’s a best practice when using Javascript to stick to const and let so you don’t have to worry about function scope outside of the concept of block scope.</p><p>The difference when using var is that it makes variables accessible anywhere in the function outside of blocks, whereas let and const can only be accessed in the blocks in which they are defined.</p><p>We can see this illustrated in the example below:</p><pre>function functionScope() {<br>  if (true) {<br>    var x = 10;<br>    let y = 20;<br>  }<br>  console.log(x); // 10<br>  console.log(y); // ReferenceError: y is not defined<br>}<br><br>functionScope();</pre><p>In this example, both x and y are declared within the block of the if statement, but x is declared using the var keyword, while y is declared using the let keyword.</p><p>Since var has function scope, it can be accessed outside of the block, and its value is logged to the console as 10. However, let has block scope, which means it is only accessible within the block so trying to access it outside will result in a ReferenceError.</p><h3>Hoisting</h3><p>Now that we’ve talked a bit about scope, let’s work on understanding the concept of hoisting. Essentially, hoisting takes some of your code and moves it to the top of its scope before the file is executed automatically with Javascript.</p><p>What get’s hoisted?</p><p>Function declarations (functions created using the function keyword) are hoisted in their entirety. Consider this example and feel free to run it on your end:</p><pre>thisGetsHoisted(); //HOISTED!<br><br><br>function thisGetsHoisted() {<br>  console.log('HOISTED!');<br>}</pre><p>The function is called before it is declared, but it still works! The reason for this is that the Javascript engine automatically hoists function declarations to the very top of the scope that the function occupies at runtime. Because of that, it has already stored thisGetsHoisted in memory such that it can be accessed before the file actually gets run.</p><p>Be careful though because the same thing will not happen with anonymous functions instantiated with let or const.</p><pre>thisGetsHoisted(); //ReferenceError: Cannot access 'thisGetsHoisted' before initialization<br><br><br>const thisGetsHoisted = () => {<br>  console.log('HOISTED!');<br>}</pre><p>The let and const keywords are not hoisted in the same way as function declarations. Space is also made for them in memory, but no value is assigned by Javascript which means a ReferenceError is thrown. Using anonymous functions with let and const helps you avoid the tricky behavior that can come about with hoisting in that it forces you to write your code such that functions are created in space <em>before</em> they are run.</p><p>We see the same thing if we attempt to access a variable rather than a function:</p><pre>console.log(isntHoisted); //ReferenceError: Cannot access 'isntHoisted' before initialization<br><br>let isntHoisted = 'nope';</pre><p>The var keyword has different behavior here (you knew it was coming). The Javascript engine will also create space in memory for var variables before running a file but instead of not assigning a value for those variables, Javascript will set them to undefined . Behaviorally, this means you still can’t use them before you initialize them (set a variable for them) in space, but you won’t get a ReferenceError if you try. Instead, the variable will just be treated as what it is, undefined:</p><pre>console.log(isntHoisted); //undefined<br><br>var isntHoisted = 'nope';</pre><p>Essentially, all variable and functions are hoisted to the top of their perspective scopes, but only function declarations get hoisted with their values (the functions themselves). The let and const keywords allow their variable keys to be hoisted, but the values they hold won’t be. Those variables also won’t be assigned a value at all in the hoisting process. As we’ve seen, var keys will also be hoisted but they’ll be set to undefined until the file is run and a value is assigned to them in the same way as let and const . The span of time between when a variable is hoisted and when it is initialized (given a value) is called the temporal dead zone.</p><p>Another thing to know about hoisting is that it can slow down your program as extra work needs to be accomplished before your file will be executed in the form of pulling all of those variables and function declarations to the top of the page. To limit this slowdown, it is advised to use let, const, and anonymous functions so that less information needs to be stored in memory before a file runs. The slowdown here is generally pretty minimal but it’s still something to keep in mind. It’s also best practice to limit the scope of variables as much as possible so they can get removed from memory (<a href=\"https://medium.com/@spencer.attick/memory-automatic-memory-management-garbage-collection-in-javascript-a8add44f764d\">garbage collected</a>) when they aren’t needed anymore rather than having them hang around in the memory heap indefintiely. This can take the form of scoping variables to modules or functions rather than creating variables in the global scope.</p><h3>Closure</h3><p>The last Javascript concept we’ll look at is closure. Closure refers to a function that has access to variables in an outer function, even after the outer function has returned. The values associated with the outer function are held in memory even after the out function is called. That was a lot, so let’s look at an example.</p><p>Here we have a function which returns another function:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jVtP0g6GSTrreAzmhAN_yA.png\" /></figure><p>Note that the inner function, secondFunction, returns a console.log of the arguments of both secondFunction and firstFunction.</p><p>On line 10, a call to firstFunction is made with 1 passed in as an argument. We might expect that value of 1 to be available only on line 10 as that is where the function call is made with 1 as an argument. Notice that the call to secondFunction isn’t made (where the arguments for both functions are meant to be printed out) until line 14.</p><p>This is where closure comes in!</p><p>In this example, secondFunction has closure over over firstFunction meaning that secondFunction not only has access to its own scope, but also the scope of the outer function (firstFunction). This includes any context firstFunction has <em>even after </em>it’s executed - which is pretty magical.</p><p>Keep in mind that closure only works if you’re calling the inner function directly. If you attempt to log out a variable in the outer function without calling the inner function, that won’t work:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*urh7VM9HFN9S0qEE-CBXng.png\" /></figure><p>Notice on line 14, instead of calling a function, I’m just trying to log out first which is only scoped to firstFunction and (because of closure) secondFunction. The first variable cannot be referenced alone in the global space as first isn’t a globally scoped variable. It’s function (or block) scoped.</p><p>Scope, hoisting, and closure are more advanced Javascript topics so I’d encourage you to continue to seek out examples and practice with them to really internalize what’s happening with your code in terms of each concept. I’ve shared some resources below that are a good next step for anything you’d like more information on.</p><h3>References</h3><p><strong>Hoisting</strong></p><p><a href=\"https://www.youtube.com/watch?v=EvfRXyKa_GI\">https://www.youtube.com/watch?v=EvfRXyKa_GI</a></p><p><a href=\"https://www.youtube.com/watch?v=_uTDzYyYz-U\">https://www.youtube.com/watch?v=_uTDzYyYz-U</a></p><p><a href=\"https://www.youtube.com/watch?v=j-9_15QBW2s\">https://www.youtube.com/watch?v=j-9_15QBW2s</a></p><p><a href=\"https://www.youtube.com/watch?v=ppMlvGMT2qE\">https://www.youtube.com/watch?v=ppMlvGMT2qE</a></p><p><strong>Scope</strong></p><p><a href=\"https://www.youtube.com/watch?v=TkFN6e9ZDMw\">https://www.youtube.com/watch?v=TkFN6e9ZDMw</a></p><p><a href=\"https://www.youtube.com/watch?v=bD-62OMzni0\">https://www.youtube.com/watch?v=bD-62OMzni0</a></p><p><a href=\"https://www.youtube.com/watch?v=ppMlvGMT2qE\">https://www.youtube.com/watch?v=ppMlvGMT2qE</a></p><p><strong>Closure</strong></p><p><a href=\"https://www.youtube.com/watch?v=3a0I8ICR1Vg&t=27s\">https://www.youtube.com/watch?v=3a0I8ICR1Vg&t=27s</a></p><p><a href=\"https://www.youtube.com/watch?v=vKJpN5FAeF4\">https://www.youtube.com/watch?v=vKJpN5FAeF4</a></p><p><a href=\"https://www.youtube.com/watch?v=1S8SBDhA7HA\">https://www.youtube.com/watch?v=1S8SBDhA7HA</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7f03b1b9e1b9\" width=\"1\" height=\"1\" alt=\"\">","enclosures":[],"content_encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*qJ8E0-P3Y7pMgstD\" /></figure><p>So you’ve learned how to execute functions and have maybe even written a few simple programs. Nice! Now it’s time to level up with some more advanced Javascript concepts. Understanding scope, hoisting, and closure are essential to internalizing how your programs will run and what behavior you can expect for certain situations that can really trip you up if you’re unclear on these concepts.</p><p>Let’s get into it!</p><h3>Scope</h3><p>The first of these concepts to understand is scope. When we’re talking about scope we’re referring to where in the program variables are accessible. There are four types of scope:</p><p><strong>Global Scope</strong></p><p>With global scope, variables are declared in such a way that makes them accessible to an entire file. To scope variables globally you just declare them outside of any functions or modules. This isn’t recommended as you might declare a global variable, forget about it, and then attempt to use the same variable in a different way elsewhere in you code which can create unexpected behavior and cause confusion, especially if you’re working with a team.</p><p>Here is an example of a variable defined with global scope:</p><pre>// Define a global variable<br>let globalVariable = 'I am a global variable';<br><br>// Define a global function<br>function globalFunction() {<br>  console.log(globalVariable);<br>}<br><br>// Call the global function from anywhere in the program<br>globalFunction(); // outputs: 'I am a global variable'</pre><p>The globalVariable and globalFunction values can be referenced anywhere in the file in which they are instantiated (though there are some limitations around hoisting which we’ll discuss later).</p><p>In Javascript, each file you create has its own global scope. You can’t share information between files without modular scope.</p><p><strong>Modular Scope</strong></p><p>Modular scope refers to a process by which variables are encapsulated in a module (ES6 offers this functionality). That module can then be shared with other parts of your program. With modular scope, variables and functions can be accessed in their own module and any other places where that module is imported.</p><p>Here is an example:</p><pre>// Define a module<br>module.exports = {<br>  moduleVariable: 'I am a module variable',<br>  moduleFunction: function() {<br>    console.log(this.moduleVariable);<br>  }<br>};</pre><pre>// Import the module into another file<br>const myModule = require('./myModule');<br><br>// Call the module function<br>myModule.moduleFunction(); // outputs: 'I am a module variable'</pre><p><strong>Block Scope</strong></p><p>Block scope refers to anything contained between two curly braces {} . This includes things like variables created within a function or variables between curly braces inif statements.</p><p>Here in an example of block scoping:</p><pre>if (true) {<br>  let x = 10;<br>}<br>console.log(x); // ReferenceError: x is not defined</pre><p>The x variable is blocked scoped (due to the use of let) and cannot be referenced outside of the curly braces it is contained in.</p><p>Please note here that var is function scoped (we’ll talk about this in just a second) but let and const are block scoped. I won’t go into that too much about var here, but in 2023 there are very few cases where it is needed so Javascript developers should be sticking with let and const .</p><p><strong>Function Scope</strong></p><p>Function scope and block scope are essentially the same thing unless you’re using the var keyword. It’s a best practice when using Javascript to stick to const and let so you don’t have to worry about function scope outside of the concept of block scope.</p><p>The difference when using var is that it makes variables accessible anywhere in the function outside of blocks, whereas let and const can only be accessed in the blocks in which they are defined.</p><p>We can see this illustrated in the example below:</p><pre>function functionScope() {<br>  if (true) {<br>    var x = 10;<br>    let y = 20;<br>  }<br>  console.log(x); // 10<br>  console.log(y); // ReferenceError: y is not defined<br>}<br><br>functionScope();</pre><p>In this example, both x and y are declared within the block of the if statement, but x is declared using the var keyword, while y is declared using the let keyword.</p><p>Since var has function scope, it can be accessed outside of the block, and its value is logged to the console as 10. However, let has block scope, which means it is only accessible within the block so trying to access it outside will result in a ReferenceError.</p><h3>Hoisting</h3><p>Now that we’ve talked a bit about scope, let’s work on understanding the concept of hoisting. Essentially, hoisting takes some of your code and moves it to the top of its scope before the file is executed automatically with Javascript.</p><p>What get’s hoisted?</p><p>Function declarations (functions created using the function keyword) are hoisted in their entirety. Consider this example and feel free to run it on your end:</p><pre>thisGetsHoisted(); //HOISTED!<br><br><br>function thisGetsHoisted() {<br>  console.log('HOISTED!');<br>}</pre><p>The function is called before it is declared, but it still works! The reason for this is that the Javascript engine automatically hoists function declarations to the very top of the scope that the function occupies at runtime. Because of that, it has already stored thisGetsHoisted in memory such that it can be accessed before the file actually gets run.</p><p>Be careful though because the same thing will not happen with anonymous functions instantiated with let or const.</p><pre>thisGetsHoisted(); //ReferenceError: Cannot access 'thisGetsHoisted' before initialization<br><br><br>const thisGetsHoisted = () => {<br>  console.log('HOISTED!');<br>}</pre><p>The let and const keywords are not hoisted in the same way as function declarations. Space is also made for them in memory, but no value is assigned by Javascript which means a ReferenceError is thrown. Using anonymous functions with let and const helps you avoid the tricky behavior that can come about with hoisting in that it forces you to write your code such that functions are created in space <em>before</em> they are run.</p><p>We see the same thing if we attempt to access a variable rather than a function:</p><pre>console.log(isntHoisted); //ReferenceError: Cannot access 'isntHoisted' before initialization<br><br>let isntHoisted = 'nope';</pre><p>The var keyword has different behavior here (you knew it was coming). The Javascript engine will also create space in memory for var variables before running a file but instead of not assigning a value for those variables, Javascript will set them to undefined . Behaviorally, this means you still can’t use them before you initialize them (set a variable for them) in space, but you won’t get a ReferenceError if you try. Instead, the variable will just be treated as what it is, undefined:</p><pre>console.log(isntHoisted); //undefined<br><br>var isntHoisted = 'nope';</pre><p>Essentially, all variable and functions are hoisted to the top of their perspective scopes, but only function declarations get hoisted with their values (the functions themselves). The let and const keywords allow their variable keys to be hoisted, but the values they hold won’t be. Those variables also won’t be assigned a value at all in the hoisting process. As we’ve seen, var keys will also be hoisted but they’ll be set to undefined until the file is run and a value is assigned to them in the same way as let and const . The span of time between when a variable is hoisted and when it is initialized (given a value) is called the temporal dead zone.</p><p>Another thing to know about hoisting is that it can slow down your program as extra work needs to be accomplished before your file will be executed in the form of pulling all of those variables and function declarations to the top of the page. To limit this slowdown, it is advised to use let, const, and anonymous functions so that less information needs to be stored in memory before a file runs. The slowdown here is generally pretty minimal but it’s still something to keep in mind. It’s also best practice to limit the scope of variables as much as possible so they can get removed from memory (<a href=\"https://medium.com/@spencer.attick/memory-automatic-memory-management-garbage-collection-in-javascript-a8add44f764d\">garbage collected</a>) when they aren’t needed anymore rather than having them hang around in the memory heap indefintiely. This can take the form of scoping variables to modules or functions rather than creating variables in the global scope.</p><h3>Closure</h3><p>The last Javascript concept we’ll look at is closure. Closure refers to a function that has access to variables in an outer function, even after the outer function has returned. The values associated with the outer function are held in memory even after the out function is called. That was a lot, so let’s look at an example.</p><p>Here we have a function which returns another function:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jVtP0g6GSTrreAzmhAN_yA.png\" /></figure><p>Note that the inner function, secondFunction, returns a console.log of the arguments of both secondFunction and firstFunction.</p><p>On line 10, a call to firstFunction is made with 1 passed in as an argument. We might expect that value of 1 to be available only on line 10 as that is where the function call is made with 1 as an argument. Notice that the call to secondFunction isn’t made (where the arguments for both functions are meant to be printed out) until line 14.</p><p>This is where closure comes in!</p><p>In this example, secondFunction has closure over over firstFunction meaning that secondFunction not only has access to its own scope, but also the scope of the outer function (firstFunction). This includes any context firstFunction has <em>even after </em>it’s executed - which is pretty magical.</p><p>Keep in mind that closure only works if you’re calling the inner function directly. If you attempt to log out a variable in the outer function without calling the inner function, that won’t work:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*urh7VM9HFN9S0qEE-CBXng.png\" /></figure><p>Notice on line 14, instead of calling a function, I’m just trying to log out first which is only scoped to firstFunction and (because of closure) secondFunction. The first variable cannot be referenced alone in the global space as first isn’t a globally scoped variable. It’s function (or block) scoped.</p><p>Scope, hoisting, and closure are more advanced Javascript topics so I’d encourage you to continue to seek out examples and practice with them to really internalize what’s happening with your code in terms of each concept. I’ve shared some resources below that are a good next step for anything you’d like more information on.</p><h3>References</h3><p><strong>Hoisting</strong></p><p><a href=\"https://www.youtube.com/watch?v=EvfRXyKa_GI\">https://www.youtube.com/watch?v=EvfRXyKa_GI</a></p><p><a href=\"https://www.youtube.com/watch?v=_uTDzYyYz-U\">https://www.youtube.com/watch?v=_uTDzYyYz-U</a></p><p><a href=\"https://www.youtube.com/watch?v=j-9_15QBW2s\">https://www.youtube.com/watch?v=j-9_15QBW2s</a></p><p><a href=\"https://www.youtube.com/watch?v=ppMlvGMT2qE\">https://www.youtube.com/watch?v=ppMlvGMT2qE</a></p><p><strong>Scope</strong></p><p><a href=\"https://www.youtube.com/watch?v=TkFN6e9ZDMw\">https://www.youtube.com/watch?v=TkFN6e9ZDMw</a></p><p><a href=\"https://www.youtube.com/watch?v=bD-62OMzni0\">https://www.youtube.com/watch?v=bD-62OMzni0</a></p><p><a href=\"https://www.youtube.com/watch?v=ppMlvGMT2qE\">https://www.youtube.com/watch?v=ppMlvGMT2qE</a></p><p><strong>Closure</strong></p><p><a href=\"https://www.youtube.com/watch?v=3a0I8ICR1Vg&t=27s\">https://www.youtube.com/watch?v=3a0I8ICR1Vg&t=27s</a></p><p><a href=\"https://www.youtube.com/watch?v=vKJpN5FAeF4\">https://www.youtube.com/watch?v=vKJpN5FAeF4</a></p><p><a href=\"https://www.youtube.com/watch?v=1S8SBDhA7HA\">https://www.youtube.com/watch?v=1S8SBDhA7HA</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7f03b1b9e1b9\" width=\"1\" height=\"1\" alt=\"\">","media":{}},{"id":"https://medium.com/p/a8add44f764d","title":"Memory & Automatic Memory Management (Garbage Collection) in Javascript","link":"https://medium.com/@spencer.attick/memory-automatic-memory-management-garbage-collection-in-javascript-a8add44f764d?source=rss-e5dc359f27c2------2","author":"Spencer Attick (he/him)","published":1674931467000,"created":1674931467000,"category":["javascript","chrome","v8-engine","scavenging","mark-and-sweep"],"content":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*ZFGeqCn1DBKgBEdB\" /></figure><p>What is memory allocation? As a programmer working for years with languages like Javascript and Python, memory usage and management hasn’t been something I’ve had to think much about and, quite frankly, have taken for granted. Not knowing what it is or how it works has left me out of the loop in terms of the inner workings of how a few very important principles work in Javascript specifically.</p><p>So let’s take a look!</p><h4>What is memory management?</h4><p>All software programs use memory in some form or another. When we’re talking about memory we’re referring to physical space that is needed to define and run files on a computer. These days, technology is improving more and more to the point where the physical components that store and process memory are smaller than every before which means that even something as the size of your phone is extremely powerful in terms of what it can do with the physical memory allocation it has (especially compared to the room-sized computers of the past— check out a <a href=\"https://www.computerhistory.org/timeline/computers/\">visual history of computers here</a>). To control what is using space on a device, memory management is used.</p><p>Memory management refers to the process by which variable values and other references are removed from memory when a program no longer uses them. For example:</p><pre>let testVar = 'Some string';<br>testVar = null;</pre><p>On the first line, we’ve declared a variable testVar and have given it the value 'Some string’ . That value, 'Some string', needs to live somewhere in a computer’s memory so it can be referenced later. However, on the second line, we’re setting testVar to null which removes the reference of testVar to 'Some string' making 'Some string' a piece of data that now lives in memory without a useable reference to it. Remember, memory usage on a computer denotes a usage of physical space so we can’t just leave 'Some string' floating around in memory indefinitely. If we did, all of those unreferenced pieces of data would eventually take up all of the available space a computer has for memory and then your computer would become useless (rather needlessly).</p><p>Some programming languages require the engineer to manage the memory needed to store data in things like variables manually. These languages are closer to machine code in nature and are known as low-level languages, such as C++. Others, know as high-level languages like Javascript, Python, and Ruby, have much of the complexity of managing memory on a program abstracted away by making those processes automatic.</p><h4>How is memory stored in Javascript?</h4><p>Javascript has two mechanisms for storing memory: the stack and the heap.</p><p><strong>The Stack</strong></p><p>Primitive data types (string, number, boolean, etc.) have their <strong>values</strong><em> </em>stored in the stack along with their <strong>keys</strong> or <strong>references</strong>.</p><p>For example the following would be stored in a stack:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/824/1*XmRS03cFozLTCN-52EJ3QA.png\" /></figure><p>A stack allocates a constant amount of data per item which means primitive types have a limit in terms of how large they can become which is known as static memory allocation.</p><p><strong>The Heap</strong></p><p>We’ve seen that the stack will hold references to data and the data itself for primitive data types. What about objects, functions, and arrays?</p><p>We call these reference data types in terms of memory management. This is because the stack will hold <strong>references</strong><em> </em>to objects, functions, and arrays but <strong>will not store those values</strong> itself. Reference data types have their values stored in a heap.</p><p>Here we can see that the reference types listed in the stack groceryList (an array) and menu (an object), have a reference in the stack but their values in the heap:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wjn6YCCTAEi78R5FPzT9-Q.png\" /></figure><p>The heap can do what’s called dynamic memory allocation to adjust for the space that a reference data type is using. The only limit to the amount of space a reference data type can use is the amount of total memory available for usage.</p><h4>Why does this matter for day-to-day Javascript programming?</h4><p>As a Javascript developer, you need to keep this storage system in mind as it impacts how your variables are stored and updated.</p><p>For example, take a look at this code:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e1DZ0ypHKY67f3TJ9ZaYHQ.png\" /></figure><p>Notice that setting newMenu to menu and then updating newMenu actually updates both newMenu and menu. That is because when you assign newMenu to menu, they’re then both pointing to the same exact object in the heap.</p><p>Be careful with this though. Consider the following example:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*FJv6Q8yeg0cWAjumhtb-Wg.png\" /></figure><p>We have the same situation here as with the first example. The newMenu variable points at menu. So why, when the console.logs() are run, do both variables not resolve to an empty object since newMenu was set to {} on line 9? Aren’t both menu and newMenu pointing to the same spot in memory?</p><p>They were! But on line 9 when newMenu was set equal to {}, it’s actually being reassigned to a new object. Now menu is still pointing at the original object but, by using the = assignment operator, newMenu is now pointing at a new empty object so the variables are no longer connected.</p><p>This works the same way with arrays and functions:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zfi6C3QD0hWaj4YnDTI8Bg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*a-oQjEnarvy0bkohZiFz5A.png\" /></figure><p>Now that we know a little more about what memory in Javascript looks like, what happens when we have a reference that’s no longer used?</p><h4>Garbage Collection</h4><p>Automatic Memory Management (known more colloquially as garbage collection) is the system by which Javascript engines decide which references no longer exist and remove them. This happens out-of-the-box and in such a way that engineers usually don’t need to be too concerned with it their day to day work.</p><p>Javascript’s V8 engine (which powers Chrome and Node.js) uses a method called generational garbage collection which involves processes called scavenging and mark-and-sweep.</p><p><strong>Generational Garbage Collection</strong></p><p>The V8 engine keeps track of new and old data (referred to as “generations”) by taking brand new data and running it through a process called scavenging. It will run its scavenging mechanism several times on the same data (new generation data) such that data that continues to be referenced will be kept and data that loses its references will be removed from memory. Data that remains after several scavenging cycles will be moved out of the space that new data had been occupying and will be stored in a longer term manner where garbage collection, called mark-and-sweep at this next phase, will happen more infrequently. This data is now considered old generation data.</p><p><strong>Scavenging</strong></p><p>Brand new data coming into memory is scavenged several times before memory graduates to become old generation in memory. During the process of scavenging, data with existing references are copied to a new space. The previous space where this data existed is cleared of data that no longer has references and that space is then ready to ingest data that has yet to be seen (even newer data) into memory. This scavenging process will happen to data a few times before data is moved considered “old generation”. Scavenging is a fast method of garbage collection that happens with new data that is most likely to lose its reference quickly. Once data graduates to old generation it is then no longer scavenged but is subject to the more infrequent process of mark-and-sweep instead.</p><p><strong>Mark-and-Sweep</strong></p><p>With mark-and-sweep, the Javascript garbage collector mechanism will traverse all data in the old generation of memory and will “mark” any data that has an existing reference with which that data is reachable by programs being run on a machine. Then, in its second phase of operation, any data that has not been marked will be cleared away and removed from memory.</p><h3>Resources</h3><p><a href=\"https://www.youtube.com/watch?v=Hci9Bb4_fkA\">https://www.youtube.com/watch?v=Hci9Bb4_fkA</a> (great video about memory)</p><p><a href=\"https://www.youtube.com/watch?v=AeUCN2lPqL8\">https://www.youtube.com/watch?v=AeUCN2lPqL8</a> (pretty good — longer and a little less straightforward)</p><p><a href=\"https://www.youtube.com/watch?v=DIzouoy13UM\">https://www.youtube.com/watch?v=DIzouoy13UM</a></p><p><a href=\"https://felixgerschau.com/javascript-memory-management/\">https://felixgerschau.com/javascript-memory-management/</a> (very good)</p><p><a href=\"https://www.youtube.com/watch?v=FZkCh_GeftY\">https://www.youtube.com/watch?v=FZkCh_GeftY</a> (good examples/explanation of reference-counting and mark and sweep)</p><p><a href=\"https://www.geeksforgeeks.org/memory-management-in-javascript/\">https://www.geeksforgeeks.org/memory-management-in-javascript/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a8add44f764d\" width=\"1\" height=\"1\" alt=\"\">","enclosures":[],"content_encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*ZFGeqCn1DBKgBEdB\" /></figure><p>What is memory allocation? As a programmer working for years with languages like Javascript and Python, memory usage and management hasn’t been something I’ve had to think much about and, quite frankly, have taken for granted. Not knowing what it is or how it works has left me out of the loop in terms of the inner workings of how a few very important principles work in Javascript specifically.</p><p>So let’s take a look!</p><h4>What is memory management?</h4><p>All software programs use memory in some form or another. When we’re talking about memory we’re referring to physical space that is needed to define and run files on a computer. These days, technology is improving more and more to the point where the physical components that store and process memory are smaller than every before which means that even something as the size of your phone is extremely powerful in terms of what it can do with the physical memory allocation it has (especially compared to the room-sized computers of the past— check out a <a href=\"https://www.computerhistory.org/timeline/computers/\">visual history of computers here</a>). To control what is using space on a device, memory management is used.</p><p>Memory management refers to the process by which variable values and other references are removed from memory when a program no longer uses them. For example:</p><pre>let testVar = 'Some string';<br>testVar = null;</pre><p>On the first line, we’ve declared a variable testVar and have given it the value 'Some string’ . That value, 'Some string', needs to live somewhere in a computer’s memory so it can be referenced later. However, on the second line, we’re setting testVar to null which removes the reference of testVar to 'Some string' making 'Some string' a piece of data that now lives in memory without a useable reference to it. Remember, memory usage on a computer denotes a usage of physical space so we can’t just leave 'Some string' floating around in memory indefinitely. If we did, all of those unreferenced pieces of data would eventually take up all of the available space a computer has for memory and then your computer would become useless (rather needlessly).</p><p>Some programming languages require the engineer to manage the memory needed to store data in things like variables manually. These languages are closer to machine code in nature and are known as low-level languages, such as C++. Others, know as high-level languages like Javascript, Python, and Ruby, have much of the complexity of managing memory on a program abstracted away by making those processes automatic.</p><h4>How is memory stored in Javascript?</h4><p>Javascript has two mechanisms for storing memory: the stack and the heap.</p><p><strong>The Stack</strong></p><p>Primitive data types (string, number, boolean, etc.) have their <strong>values</strong><em> </em>stored in the stack along with their <strong>keys</strong> or <strong>references</strong>.</p><p>For example the following would be stored in a stack:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/824/1*XmRS03cFozLTCN-52EJ3QA.png\" /></figure><p>A stack allocates a constant amount of data per item which means primitive types have a limit in terms of how large they can become which is known as static memory allocation.</p><p><strong>The Heap</strong></p><p>We’ve seen that the stack will hold references to data and the data itself for primitive data types. What about objects, functions, and arrays?</p><p>We call these reference data types in terms of memory management. This is because the stack will hold <strong>references</strong><em> </em>to objects, functions, and arrays but <strong>will not store those values</strong> itself. Reference data types have their values stored in a heap.</p><p>Here we can see that the reference types listed in the stack groceryList (an array) and menu (an object), have a reference in the stack but their values in the heap:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wjn6YCCTAEi78R5FPzT9-Q.png\" /></figure><p>The heap can do what’s called dynamic memory allocation to adjust for the space that a reference data type is using. The only limit to the amount of space a reference data type can use is the amount of total memory available for usage.</p><h4>Why does this matter for day-to-day Javascript programming?</h4><p>As a Javascript developer, you need to keep this storage system in mind as it impacts how your variables are stored and updated.</p><p>For example, take a look at this code:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e1DZ0ypHKY67f3TJ9ZaYHQ.png\" /></figure><p>Notice that setting newMenu to menu and then updating newMenu actually updates both newMenu and menu. That is because when you assign newMenu to menu, they’re then both pointing to the same exact object in the heap.</p><p>Be careful with this though. Consider the following example:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*FJv6Q8yeg0cWAjumhtb-Wg.png\" /></figure><p>We have the same situation here as with the first example. The newMenu variable points at menu. So why, when the console.logs() are run, do both variables not resolve to an empty object since newMenu was set to {} on line 9? Aren’t both menu and newMenu pointing to the same spot in memory?</p><p>They were! But on line 9 when newMenu was set equal to {}, it’s actually being reassigned to a new object. Now menu is still pointing at the original object but, by using the = assignment operator, newMenu is now pointing at a new empty object so the variables are no longer connected.</p><p>This works the same way with arrays and functions:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zfi6C3QD0hWaj4YnDTI8Bg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*a-oQjEnarvy0bkohZiFz5A.png\" /></figure><p>Now that we know a little more about what memory in Javascript looks like, what happens when we have a reference that’s no longer used?</p><h4>Garbage Collection</h4><p>Automatic Memory Management (known more colloquially as garbage collection) is the system by which Javascript engines decide which references no longer exist and remove them. This happens out-of-the-box and in such a way that engineers usually don’t need to be too concerned with it their day to day work.</p><p>Javascript’s V8 engine (which powers Chrome and Node.js) uses a method called generational garbage collection which involves processes called scavenging and mark-and-sweep.</p><p><strong>Generational Garbage Collection</strong></p><p>The V8 engine keeps track of new and old data (referred to as “generations”) by taking brand new data and running it through a process called scavenging. It will run its scavenging mechanism several times on the same data (new generation data) such that data that continues to be referenced will be kept and data that loses its references will be removed from memory. Data that remains after several scavenging cycles will be moved out of the space that new data had been occupying and will be stored in a longer term manner where garbage collection, called mark-and-sweep at this next phase, will happen more infrequently. This data is now considered old generation data.</p><p><strong>Scavenging</strong></p><p>Brand new data coming into memory is scavenged several times before memory graduates to become old generation in memory. During the process of scavenging, data with existing references are copied to a new space. The previous space where this data existed is cleared of data that no longer has references and that space is then ready to ingest data that has yet to be seen (even newer data) into memory. This scavenging process will happen to data a few times before data is moved considered “old generation”. Scavenging is a fast method of garbage collection that happens with new data that is most likely to lose its reference quickly. Once data graduates to old generation it is then no longer scavenged but is subject to the more infrequent process of mark-and-sweep instead.</p><p><strong>Mark-and-Sweep</strong></p><p>With mark-and-sweep, the Javascript garbage collector mechanism will traverse all data in the old generation of memory and will “mark” any data that has an existing reference with which that data is reachable by programs being run on a machine. Then, in its second phase of operation, any data that has not been marked will be cleared away and removed from memory.</p><h3>Resources</h3><p><a href=\"https://www.youtube.com/watch?v=Hci9Bb4_fkA\">https://www.youtube.com/watch?v=Hci9Bb4_fkA</a> (great video about memory)</p><p><a href=\"https://www.youtube.com/watch?v=AeUCN2lPqL8\">https://www.youtube.com/watch?v=AeUCN2lPqL8</a> (pretty good — longer and a little less straightforward)</p><p><a href=\"https://www.youtube.com/watch?v=DIzouoy13UM\">https://www.youtube.com/watch?v=DIzouoy13UM</a></p><p><a href=\"https://felixgerschau.com/javascript-memory-management/\">https://felixgerschau.com/javascript-memory-management/</a> (very good)</p><p><a href=\"https://www.youtube.com/watch?v=FZkCh_GeftY\">https://www.youtube.com/watch?v=FZkCh_GeftY</a> (good examples/explanation of reference-counting and mark and sweep)</p><p><a href=\"https://www.geeksforgeeks.org/memory-management-in-javascript/\">https://www.geeksforgeeks.org/memory-management-in-javascript/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a8add44f764d\" width=\"1\" height=\"1\" alt=\"\">","media":{}},{"id":"https://medium.com/p/5f5bfabd3a89","title":"A First Look at the Javascript Event Loop on the Browser","link":"https://medium.com/@spencer.attick/a-first-look-at-the-javascript-event-loop-on-the-browser-5f5bfabd3a89?source=rss-e5dc359f27c2------2","author":"Spencer Attick (he/him)","published":1674060961000,"created":1674060961000,"category":["programming","javascript","javascript-event-loop","code","event-loop"],"content":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*WAv7Lkf0hWx9Rowd\" /></figure><p>When you execute Javascript on the client, there are some behind-the-scenes processes that make the magic happen. As Javascript is a single-threaded language (it can only do one thing at a time), it needs a way to be told what aspects of your codebase should be run immediately, which should wait on things like API responses and timeouts, and in what order all of that should happen.</p><p>Enter, the Event Loop!</p><p>The Event Loop takes care of managing the execution of your program in a way that accounts for asynchronous behavior, the nesting of functions, and more.</p><h4>What does the Event Loop look like?</h4><p>At a high level, we can think of the Event Loop like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YgNN1CVEVXz_XnZoVkNjcw.png\" /></figure><p>Before we step through any code, let’s align on each of these pieces.</p><p>The <strong>Code Input</strong> will simply be the Javascript file you intend to run.</p><p>The <strong>Call Stack</strong> refers to a mechanism that processes each element in your code. It is a <a href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\">stack data structure</a> which is known as first-in-last-out. That means that the first item that is pushed into the Call Stack (as with any stack) will be processed last. It’s like if you went to the library and searched the selves for books you wanted to take home. If you placed each book you found on top of the last, you’d have a pile of books with the first book you took off of the selves on the bottom and the most recent book you found on top. If you handed that pile to the librarian, they would likely take the top book from the pile to check it out for you first. Operating in that manner, they would check out the FIRST book you found on the shelves LAST (after checking all the other books out for you).</p><p>The <strong>Outside API/Javascript API </strong>section refers to an act of using one of the API methods available in the browser (like setTimeout) or the use of another outside API. When requests are made out to APIs, those actions are generally considered asynchronous as they deviate from Javascript running and completing tasks line by line, in order (synchronously).</p><p>The <strong>Event Queue </strong>is a <a href=\"https://en.wikipedia.org/wiki/Queue_(abstract_data_type)#:~:text=In%20computer%20science%2C%20a%20queue,other%20end%20of%20the%20sequence.\">queue data structure</a> similar to a stack, but rather than being first-in-last-out, a queue is first-in-first-out. In terms of a queue, you can think of waiting in a line at the grocery store. If you enter the line first, the cashier will help you to check out before everyone else in the line. If you enter the line last, you’ll have to wait for each customer in front of you to check out, in order, before you’ll be allowed to check out. The first person in the line is the first person to have their groceries scanned and to leave. All programming queues work in this way, including the Event Queue.</p><p>The <strong>Event Loop </strong>is a mechanism that keeps track of whether or not there are any operations needing to be processed in the Event Queue. If there are items that need handling in the queue, it will loop through them and add them to the Call Stack one at a time. The Event Loop can only add items to the Call Stack if the Call Stack is totally empty.</p><p>Finally, the <strong>Code Output </strong>will help us visualize how the Code Input is run in terms of letting us see the order of operations. Consider this depiction to be something like running a file from your browser to see what prints in the console out and when.</p><h4>How does the Event Loop work?</h4><p>Now that we have a sense of the different parts of this process and a high-level understanding of each, let’s look at an example to help us understand how a file is read in Javascript and how each line is fed through the Event Loop.</p><p>To begin, the first line is a console.log() which is pushed into the Call Stack:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zn9T2g1CWAmQSdq5m03HTg.png\" /></figure><p>There isn’t any process to wait on here in order for the console.log() to complete, so it’s immediately resolved from the stack and the result is displayed in the Code Output section of this diagram but you can imagine this would be printed to the console of the browser:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mBn2hXD9OcaIBLW6tF8D5g.png\" /></figure><p>With that, the first line is processed and First line to run! is printed out.</p><p>Next we’ll look at a setTimeout() function which actually makes use of a timer API available in the browser to keep track of when the milliseconds passed in as the second argument to that function have transpired:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*x2ptopNgLwIHPYA9fWefpw.png\" /></figure><p>First, the setTimeout() is added to the Call Stack. If you’re unfamiliar, this function takes two arguments: a function to execute and a number to represent the amount of milliseconds to wait until the function passed in as the first argument is called.</p><p>The mechanism that keeps track of the time here is a built-in browser API. As that is the case, the next step will be to invoke that timer on the browser itself:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*j0s2UbhwsHgiT4KycbzWaw.png\" /></figure><p>With the timer set to run on the browser, the setTimeout() function is finished being processed in the Call Stack. Next we can look at the console.log() on line 7 while wait for the browser API to return the callback we passed to setTimeout() . I encourage you to think through what you expect to happen before continuing on:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Trm56HiRtpb1x65jsSoCEA.png\" /></figure><p>As with the previous console.log() , this one can be resolved immediately from the Call Stack and Last line to run! will be printed in the Code Output:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HRPuhA7twGNjNJJL_1yEkg.png\" /></figure><p>Now, we can imagine the 1000 milliseconds have completed and the browser API is now ready to send the callback in to be processed. This looks like the API handing the callback to the Event Queue. Remember, Javascript can only do one thing at a time so if it was still resolving the console.log() on line 7 by the time 1000 milliseconds had gone by, we’d need to ensure any new activity didn’t interrupt any currently running processes. To that end, the callback is handed to the Event Queue to await a time when the Call Stack is completely cleared:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vq5mT46keKLPOpbBMTPfwQ.png\" /></figure><p>The Event Loop will run when the Call Stack is completely clear to see what’s in the Event Queue:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3crn6To4pLXTJL79dl4ZsA.png\" /></figure><p>It sees the console.log() and pulls that into the empty Call Stack:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*t9QVR-GEq8iqydXV0-89wA.png\" /></figure><p>Now the Call Stack has the capacity to process this console.log() just like the other two:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ll2K-WhIs46qPCs7P_3a5A.png\" /></figure><p>From there, every line of code has been run and all aspects of the process are cleared. That’s it!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8GdRK-7rMQ9j-c5pC7JYJA.png\" /></figure><h4>Is that all there is to it?</h4><p>This guide is meant to give you a high-level overview of what the Event Loop is and how it works. The process has a lot more nuance if you were to spend time digging into it. Once you feel you’ve grasped the basics here, go ahead and see what else you can find!</p><p>In this article we have looked at a case where the Call Stack only has one item in it at a time, there are many instances where the Call Stack would have more than one item in it such as instances where a function calls another function. Remember, the item on the top of the Call Stack is processed first even though that is the last item to be added. Feel free to try this out yourself here: <a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a>.</p><h4>What other resources are out there to help me further understand this concept?</h4><p>There are TONS of great resources out there on the Event Loop. Here are a few that I referenced and found helpful:</p><p><a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a> — A tool that will help you visualize how your own code would run through the Event Loop.</p><p><a href=\"https://www.youtube.com/watch?v=lqLSNG_79lI\">JavaScript Event Loop Explained in 5 Minutes</a> — A quick video that is fairly thorough.</p><p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a> — A longer, more in depth look at the Event Loop (the person giving this talk created the <a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a> tool).</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5f5bfabd3a89\" width=\"1\" height=\"1\" alt=\"\">","enclosures":[],"content_encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*WAv7Lkf0hWx9Rowd\" /></figure><p>When you execute Javascript on the client, there are some behind-the-scenes processes that make the magic happen. As Javascript is a single-threaded language (it can only do one thing at a time), it needs a way to be told what aspects of your codebase should be run immediately, which should wait on things like API responses and timeouts, and in what order all of that should happen.</p><p>Enter, the Event Loop!</p><p>The Event Loop takes care of managing the execution of your program in a way that accounts for asynchronous behavior, the nesting of functions, and more.</p><h4>What does the Event Loop look like?</h4><p>At a high level, we can think of the Event Loop like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YgNN1CVEVXz_XnZoVkNjcw.png\" /></figure><p>Before we step through any code, let’s align on each of these pieces.</p><p>The <strong>Code Input</strong> will simply be the Javascript file you intend to run.</p><p>The <strong>Call Stack</strong> refers to a mechanism that processes each element in your code. It is a <a href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\">stack data structure</a> which is known as first-in-last-out. That means that the first item that is pushed into the Call Stack (as with any stack) will be processed last. It’s like if you went to the library and searched the selves for books you wanted to take home. If you placed each book you found on top of the last, you’d have a pile of books with the first book you took off of the selves on the bottom and the most recent book you found on top. If you handed that pile to the librarian, they would likely take the top book from the pile to check it out for you first. Operating in that manner, they would check out the FIRST book you found on the shelves LAST (after checking all the other books out for you).</p><p>The <strong>Outside API/Javascript API </strong>section refers to an act of using one of the API methods available in the browser (like setTimeout) or the use of another outside API. When requests are made out to APIs, those actions are generally considered asynchronous as they deviate from Javascript running and completing tasks line by line, in order (synchronously).</p><p>The <strong>Event Queue </strong>is a <a href=\"https://en.wikipedia.org/wiki/Queue_(abstract_data_type)#:~:text=In%20computer%20science%2C%20a%20queue,other%20end%20of%20the%20sequence.\">queue data structure</a> similar to a stack, but rather than being first-in-last-out, a queue is first-in-first-out. In terms of a queue, you can think of waiting in a line at the grocery store. If you enter the line first, the cashier will help you to check out before everyone else in the line. If you enter the line last, you’ll have to wait for each customer in front of you to check out, in order, before you’ll be allowed to check out. The first person in the line is the first person to have their groceries scanned and to leave. All programming queues work in this way, including the Event Queue.</p><p>The <strong>Event Loop </strong>is a mechanism that keeps track of whether or not there are any operations needing to be processed in the Event Queue. If there are items that need handling in the queue, it will loop through them and add them to the Call Stack one at a time. The Event Loop can only add items to the Call Stack if the Call Stack is totally empty.</p><p>Finally, the <strong>Code Output </strong>will help us visualize how the Code Input is run in terms of letting us see the order of operations. Consider this depiction to be something like running a file from your browser to see what prints in the console out and when.</p><h4>How does the Event Loop work?</h4><p>Now that we have a sense of the different parts of this process and a high-level understanding of each, let’s look at an example to help us understand how a file is read in Javascript and how each line is fed through the Event Loop.</p><p>To begin, the first line is a console.log() which is pushed into the Call Stack:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zn9T2g1CWAmQSdq5m03HTg.png\" /></figure><p>There isn’t any process to wait on here in order for the console.log() to complete, so it’s immediately resolved from the stack and the result is displayed in the Code Output section of this diagram but you can imagine this would be printed to the console of the browser:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mBn2hXD9OcaIBLW6tF8D5g.png\" /></figure><p>With that, the first line is processed and First line to run! is printed out.</p><p>Next we’ll look at a setTimeout() function which actually makes use of a timer API available in the browser to keep track of when the milliseconds passed in as the second argument to that function have transpired:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*x2ptopNgLwIHPYA9fWefpw.png\" /></figure><p>First, the setTimeout() is added to the Call Stack. If you’re unfamiliar, this function takes two arguments: a function to execute and a number to represent the amount of milliseconds to wait until the function passed in as the first argument is called.</p><p>The mechanism that keeps track of the time here is a built-in browser API. As that is the case, the next step will be to invoke that timer on the browser itself:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*j0s2UbhwsHgiT4KycbzWaw.png\" /></figure><p>With the timer set to run on the browser, the setTimeout() function is finished being processed in the Call Stack. Next we can look at the console.log() on line 7 while wait for the browser API to return the callback we passed to setTimeout() . I encourage you to think through what you expect to happen before continuing on:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Trm56HiRtpb1x65jsSoCEA.png\" /></figure><p>As with the previous console.log() , this one can be resolved immediately from the Call Stack and Last line to run! will be printed in the Code Output:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HRPuhA7twGNjNJJL_1yEkg.png\" /></figure><p>Now, we can imagine the 1000 milliseconds have completed and the browser API is now ready to send the callback in to be processed. This looks like the API handing the callback to the Event Queue. Remember, Javascript can only do one thing at a time so if it was still resolving the console.log() on line 7 by the time 1000 milliseconds had gone by, we’d need to ensure any new activity didn’t interrupt any currently running processes. To that end, the callback is handed to the Event Queue to await a time when the Call Stack is completely cleared:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vq5mT46keKLPOpbBMTPfwQ.png\" /></figure><p>The Event Loop will run when the Call Stack is completely clear to see what’s in the Event Queue:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3crn6To4pLXTJL79dl4ZsA.png\" /></figure><p>It sees the console.log() and pulls that into the empty Call Stack:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*t9QVR-GEq8iqydXV0-89wA.png\" /></figure><p>Now the Call Stack has the capacity to process this console.log() just like the other two:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ll2K-WhIs46qPCs7P_3a5A.png\" /></figure><p>From there, every line of code has been run and all aspects of the process are cleared. That’s it!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8GdRK-7rMQ9j-c5pC7JYJA.png\" /></figure><h4>Is that all there is to it?</h4><p>This guide is meant to give you a high-level overview of what the Event Loop is and how it works. The process has a lot more nuance if you were to spend time digging into it. Once you feel you’ve grasped the basics here, go ahead and see what else you can find!</p><p>In this article we have looked at a case where the Call Stack only has one item in it at a time, there are many instances where the Call Stack would have more than one item in it such as instances where a function calls another function. Remember, the item on the top of the Call Stack is processed first even though that is the last item to be added. Feel free to try this out yourself here: <a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a>.</p><h4>What other resources are out there to help me further understand this concept?</h4><p>There are TONS of great resources out there on the Event Loop. Here are a few that I referenced and found helpful:</p><p><a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a> — A tool that will help you visualize how your own code would run through the Event Loop.</p><p><a href=\"https://www.youtube.com/watch?v=lqLSNG_79lI\">JavaScript Event Loop Explained in 5 Minutes</a> — A quick video that is fairly thorough.</p><p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a> — A longer, more in depth look at the Event Loop (the person giving this talk created the <a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a> tool).</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5f5bfabd3a89\" width=\"1\" height=\"1\" alt=\"\">","media":{}},{"id":"https://medium.com/p/2d07585c38a5","title":"A Beginners Guide to Async/Await in Javascript","link":"https://medium.com/@spencer.attick/a-beginners-guide-to-async-await-in-javascript-2d07585c38a5?source=rss-e5dc359f27c2------2","author":"Spencer Attick (he/him)","published":1673310470000,"created":1673310470000,"category":["asynchronous","coding","code","javascript","computer-science"],"content":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XIwNByMkQk7Vr-6VxSBCWg.png\" /><figcaption>Photo courtesy of Unsplash</figcaption></figure><h3><strong>What is Async/Await?</strong></h3><p>Async/await is a concept that arose in the 2017 version of Javascript that allows for asynchronous actions (where one or more things are happening at a time in a program) to be accounted for synchronously (in order). In Javascript, <strong>asynchronous</strong> behavior generally arises in the form of <strong>API requests</strong> or <strong>manually instantiated Promises</strong>. <strong>Most other functionality in Javascript is synchronous.</strong></p><p>The usage of async/await extends the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a> feature was released into Javascript in 2015. Promises are a solution to nesting callback functions which was how asynchronous behavior was handled before Promises were released. <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function\">Callbacks</a> (a function passed to another function as an argument) created a problem, often referred to as “callback hell” where functions would be nested to the point of illegibility. Promises allowed for the chaining of functions with the .then() method in order to introduce more readability into a program. Async/await takes things a step further to move away from nesting and chaining into a syntax that looks much more like the synchronous Javascript most folks are used to.</p><p>Async/await was developed as “syntactic sugar” on top of Promises and <strong>can only be used with a Promise</strong> that has been previously created or to handle HTTP responses (which is usually a Promise under the hood).</p><p>The async keyword labels a function as containing asynchronous content (a Promise resolution or an HTTP request). The await keyword, indicates which line the program should pause on to wait for the resolution of a Promise.</p><p>Here is a simple example:</p><pre>const promiseExample = new Promise((resolve, reject) => {<br>  const randomBoolean = Math.random() < 0.5;<br>  if (randomBoolean) {<br>    console.log(randomBoolean);<br>    resolve('Boolean was true!')<br>  } else {<br>    console.log(randomBoolean);<br>    reject('Boolean was false!')<br>  }<br>})<br><br>async function asyncExample() {<br>  try {<br>    const promiseOutcome = await promiseExample;<br>    console.log('SUCCESS:', promiseOutcome);<br>  } catch(err) {<br>    console.log('ERROR:', err);<br>  }<br>}<br><br>asyncExample();</pre><p>Here we have a variable, promiseExample, which takes the result of a Promise. In this case, the randomBoolean variable will randomly resolve to either true or false . If it is true, then the Promise is coded to resolve successfully. If it’s false, then the Promise will reject, or fail.</p><p>The asyncExample function is labeled with the async keyword which indicates that it contains asynchronous content. From there, the await keyword tells the program which line to wait on until it receives a value (or an error is thrown).</p><p><strong>If an asynchronous action takes places without properly being handled, then you may find that variables that are dependent on the outcome of that asynchronous action are </strong><strong>undefined.</strong> That happens when the program attempts to read and use those variables before they have been assigned a value by the Promise structure. For that reason, it’s important to properly handle Promises with callbacks, a .then() chain, or by using async/await .</p><p>Go ahead and run the above code a few times to see what you get!</p><h3><strong>When to Use Async/Await</strong></h3><p><strong>The </strong><strong>async/await syntax is ONLY used in conjunction with Promises.</strong> It is an optimization that was designed specifically to help make the asynchronous actions that occur when Promises are involved much more readable. Async/await allows you to read code as it will execute, line by line, rather than having to jump around in your code to see what will happen next in sequence.</p><h3><strong>Advantages of using Async/Await</strong></h3><p>Async/await allows you to make your code more readable. It moves away from nesting callbacks or chaining .then() methods, both of which can make your code messy and difficult to debug.</p><p>The improvement that comes with async/await allows you to run asynchronous code line by line just as you do with synchronous code.</p><h3><strong>Error Handling</strong></h3><p>Error handling with async/await look a bit different than if you’re only using the Promise structure. Remember, with Promises, you’ll handle errors with .catch() like this:</p><pre>doSomething()<br>  .then(() => <DO SOMETHING>)  <br>  .then(() => <DO SOMETHING ELSE>)<br>  .catch((err) => <HANDLE ERROR HERE>)</pre><p>With async/await , errors are handled with a try/catch block like this:</p><pre>async function doSomething() {<br>  try {<br>    <PUT YOUR CODE HERE ALONG WITH THE AWAIT LINE(s)><br>  } catch(err) {<br>    <HANDLE ERROR HERE><br>  }<br>}</pre><p>This syntax will attempt to run your code in the try portion of the block and if ANY of the Promises referenced there with await fail, then they will be caught with the catch section of the block.</p><p><strong>Don’t forget the </strong><strong>try/catch block! </strong>If you do, and your Promise rejects then your code will throw an Unhandled Promise error as you haven’t given the error message an outlet.</p><h3><strong>Example</strong></h3><p>Now that we have a decent amount of context, let’s consider a quick example. First we can create a function that will generate a random number:</p><pre>function generateRandomNum() {<br>  const randomNum = Math.floor(Math.random() * 11);<br>  if (randomNum === 4) {<br>    return 'FOUR';<br>  } else {<br>   return randomNum; <br>  }<br>}</pre><p>You may notice that this function contains a twist to keep things interesting. It will return a random number UNLESS that number ends up being 4 in which case it will return a string, FOUR .</p><p>Next, we can create a function that returns the result of a Promise which checks the datatype of the number generated by the generateRandomNum() function. This function takes one argument, operandPosition, which will help us narrow in on whether the first or second operand (or number to be added together) is the result of a problem:</p><pre>function generateNumPromise(operandPosition) {<br>  const randomNum = generateRandomNum();<br>  let result = new Promise((resolve, reject) => {<br>    if (typeof randomNum === 'number') {<br>     resolve(randomNum);<br>    } else {<br>     reject(`There was a problem! The data type generated for the ${operandPosition} operand was not a number.`);<br>    }<br>  })<br>  console.log(`The ${operandPosition} number is ${randomNum}.`)<br>  return result;<br>}</pre><p>This function contains a Promise which will resolve (be considered successful) if randomNum is a number datatype or will reject (be considered erroneous) if randomNum is a string. Either way, a console.log will print out what each operand is each time the program is run for visibility. The result of the Promise will then be returned as result .</p><p>From there, we’ll use an async function to await the resolution of each Promise generated by calling generateNumPromise() twice. <strong>Remember, </strong><strong>async/await is only used when there is a Promise to wait for, so you’ll never need it unless you’ve added a Promise to your code or you’re making an HTTP request as those generally return Promises:</strong></p><pre>async function addNumbers() {<br>  try {<br>    const firstNum = await generateNumPromise('first');<br>    const secondNum = await generateNumPromise('second');<br>    console.log(`The sum of firstNum and secondNum = ${firstNum + secondNum}.`);<br>  } catch (err) {<br>    console.error(err);<br>  }<br>}<br><br>addNumbers();</pre><p>Here is are a couple runs of the program:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/730/1*zq5d_Kx69l7vjUzNxPikrg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kguQCMtHUzSoNwucHDY5jg.png\" /></figure><p>The first demonstrates a case where both operands involved are numbers which allows the program to complete without error.</p><p>In the second screenshot, we can see that a string was generated instead of a number which does throw an error, invoking the reject message in the try/catch block.</p><h3><strong>Key Takeaways</strong></h3><ul><li>async/await always needs to be used with Promises (remember, Node’s fetch method and other API request tools return Promises)</li><li>don’t forget to use the try/catch block for error handling so you don’t run into issues with unresolved Promises in your code</li><li>await can only be used in a function that is labeled async</li></ul><p><strong>Additional Resources</strong></p><p><a href=\"https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript\">Synchronous vs. Asynchronous in Javascript</a></p><p><a href=\"https://www.youtube.com/watch?v=li7FzDHYZpc\">Javascript Promises vs Async Await EXPLAINED (in 5 minutes)</a> video</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2d07585c38a5\" width=\"1\" height=\"1\" alt=\"\">","enclosures":[],"content_encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XIwNByMkQk7Vr-6VxSBCWg.png\" /><figcaption>Photo courtesy of Unsplash</figcaption></figure><h3><strong>What is Async/Await?</strong></h3><p>Async/await is a concept that arose in the 2017 version of Javascript that allows for asynchronous actions (where one or more things are happening at a time in a program) to be accounted for synchronously (in order). In Javascript, <strong>asynchronous</strong> behavior generally arises in the form of <strong>API requests</strong> or <strong>manually instantiated Promises</strong>. <strong>Most other functionality in Javascript is synchronous.</strong></p><p>The usage of async/await extends the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a> feature was released into Javascript in 2015. Promises are a solution to nesting callback functions which was how asynchronous behavior was handled before Promises were released. <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function\">Callbacks</a> (a function passed to another function as an argument) created a problem, often referred to as “callback hell” where functions would be nested to the point of illegibility. Promises allowed for the chaining of functions with the .then() method in order to introduce more readability into a program. Async/await takes things a step further to move away from nesting and chaining into a syntax that looks much more like the synchronous Javascript most folks are used to.</p><p>Async/await was developed as “syntactic sugar” on top of Promises and <strong>can only be used with a Promise</strong> that has been previously created or to handle HTTP responses (which is usually a Promise under the hood).</p><p>The async keyword labels a function as containing asynchronous content (a Promise resolution or an HTTP request). The await keyword, indicates which line the program should pause on to wait for the resolution of a Promise.</p><p>Here is a simple example:</p><pre>const promiseExample = new Promise((resolve, reject) => {<br>  const randomBoolean = Math.random() < 0.5;<br>  if (randomBoolean) {<br>    console.log(randomBoolean);<br>    resolve('Boolean was true!')<br>  } else {<br>    console.log(randomBoolean);<br>    reject('Boolean was false!')<br>  }<br>})<br><br>async function asyncExample() {<br>  try {<br>    const promiseOutcome = await promiseExample;<br>    console.log('SUCCESS:', promiseOutcome);<br>  } catch(err) {<br>    console.log('ERROR:', err);<br>  }<br>}<br><br>asyncExample();</pre><p>Here we have a variable, promiseExample, which takes the result of a Promise. In this case, the randomBoolean variable will randomly resolve to either true or false . If it is true, then the Promise is coded to resolve successfully. If it’s false, then the Promise will reject, or fail.</p><p>The asyncExample function is labeled with the async keyword which indicates that it contains asynchronous content. From there, the await keyword tells the program which line to wait on until it receives a value (or an error is thrown).</p><p><strong>If an asynchronous action takes places without properly being handled, then you may find that variables that are dependent on the outcome of that asynchronous action are </strong><strong>undefined.</strong> That happens when the program attempts to read and use those variables before they have been assigned a value by the Promise structure. For that reason, it’s important to properly handle Promises with callbacks, a .then() chain, or by using async/await .</p><p>Go ahead and run the above code a few times to see what you get!</p><h3><strong>When to Use Async/Await</strong></h3><p><strong>The </strong><strong>async/await syntax is ONLY used in conjunction with Promises.</strong> It is an optimization that was designed specifically to help make the asynchronous actions that occur when Promises are involved much more readable. Async/await allows you to read code as it will execute, line by line, rather than having to jump around in your code to see what will happen next in sequence.</p><h3><strong>Advantages of using Async/Await</strong></h3><p>Async/await allows you to make your code more readable. It moves away from nesting callbacks or chaining .then() methods, both of which can make your code messy and difficult to debug.</p><p>The improvement that comes with async/await allows you to run asynchronous code line by line just as you do with synchronous code.</p><h3><strong>Error Handling</strong></h3><p>Error handling with async/await look a bit different than if you’re only using the Promise structure. Remember, with Promises, you’ll handle errors with .catch() like this:</p><pre>doSomething()<br>  .then(() => <DO SOMETHING>)  <br>  .then(() => <DO SOMETHING ELSE>)<br>  .catch((err) => <HANDLE ERROR HERE>)</pre><p>With async/await , errors are handled with a try/catch block like this:</p><pre>async function doSomething() {<br>  try {<br>    <PUT YOUR CODE HERE ALONG WITH THE AWAIT LINE(s)><br>  } catch(err) {<br>    <HANDLE ERROR HERE><br>  }<br>}</pre><p>This syntax will attempt to run your code in the try portion of the block and if ANY of the Promises referenced there with await fail, then they will be caught with the catch section of the block.</p><p><strong>Don’t forget the </strong><strong>try/catch block! </strong>If you do, and your Promise rejects then your code will throw an Unhandled Promise error as you haven’t given the error message an outlet.</p><h3><strong>Example</strong></h3><p>Now that we have a decent amount of context, let’s consider a quick example. First we can create a function that will generate a random number:</p><pre>function generateRandomNum() {<br>  const randomNum = Math.floor(Math.random() * 11);<br>  if (randomNum === 4) {<br>    return 'FOUR';<br>  } else {<br>   return randomNum; <br>  }<br>}</pre><p>You may notice that this function contains a twist to keep things interesting. It will return a random number UNLESS that number ends up being 4 in which case it will return a string, FOUR .</p><p>Next, we can create a function that returns the result of a Promise which checks the datatype of the number generated by the generateRandomNum() function. This function takes one argument, operandPosition, which will help us narrow in on whether the first or second operand (or number to be added together) is the result of a problem:</p><pre>function generateNumPromise(operandPosition) {<br>  const randomNum = generateRandomNum();<br>  let result = new Promise((resolve, reject) => {<br>    if (typeof randomNum === 'number') {<br>     resolve(randomNum);<br>    } else {<br>     reject(`There was a problem! The data type generated for the ${operandPosition} operand was not a number.`);<br>    }<br>  })<br>  console.log(`The ${operandPosition} number is ${randomNum}.`)<br>  return result;<br>}</pre><p>This function contains a Promise which will resolve (be considered successful) if randomNum is a number datatype or will reject (be considered erroneous) if randomNum is a string. Either way, a console.log will print out what each operand is each time the program is run for visibility. The result of the Promise will then be returned as result .</p><p>From there, we’ll use an async function to await the resolution of each Promise generated by calling generateNumPromise() twice. <strong>Remember, </strong><strong>async/await is only used when there is a Promise to wait for, so you’ll never need it unless you’ve added a Promise to your code or you’re making an HTTP request as those generally return Promises:</strong></p><pre>async function addNumbers() {<br>  try {<br>    const firstNum = await generateNumPromise('first');<br>    const secondNum = await generateNumPromise('second');<br>    console.log(`The sum of firstNum and secondNum = ${firstNum + secondNum}.`);<br>  } catch (err) {<br>    console.error(err);<br>  }<br>}<br><br>addNumbers();</pre><p>Here is are a couple runs of the program:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/730/1*zq5d_Kx69l7vjUzNxPikrg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kguQCMtHUzSoNwucHDY5jg.png\" /></figure><p>The first demonstrates a case where both operands involved are numbers which allows the program to complete without error.</p><p>In the second screenshot, we can see that a string was generated instead of a number which does throw an error, invoking the reject message in the try/catch block.</p><h3><strong>Key Takeaways</strong></h3><ul><li>async/await always needs to be used with Promises (remember, Node’s fetch method and other API request tools return Promises)</li><li>don’t forget to use the try/catch block for error handling so you don’t run into issues with unresolved Promises in your code</li><li>await can only be used in a function that is labeled async</li></ul><p><strong>Additional Resources</strong></p><p><a href=\"https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript\">Synchronous vs. Asynchronous in Javascript</a></p><p><a href=\"https://www.youtube.com/watch?v=li7FzDHYZpc\">Javascript Promises vs Async Await EXPLAINED (in 5 minutes)</a> video</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2d07585c38a5\" width=\"1\" height=\"1\" alt=\"\">","media":{}}]}